/**
 * Module RAG - Recherche sémantique de citations via API Python.
 * Expose une fonction search() qui prend une query et retourne les résultats.
 */

const RAG_API_URL = 'http://localhost:5001/search';

/**
 * Recherche sémantique de citations via le serveur RAG.
 * @param {string} query - Phrase de recherche (ex: "j'ai besoin de calme, je me sens stressé")
 * @param {number} topK - Nombre de résultats à retourner (défaut: 5)
 * @returns {Promise<Array>} - Liste de citations avec scores
 */
export async function search(query, topK = 5) {
  if (!query || typeof query !== 'string') {
    throw new Error('Query invalide');
  }

  try {
    const response = await fetch(RAG_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ query, top_k: topK }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `Erreur serveur: ${response.status}`);
    }

    const data = await response.json();
    return data.results || [];
  } catch (error) {
    console.error('[RAG] Erreur de recherche:', error);
    throw error;
  }
}

/**
 * Construit une phrase de recherche à partir des filtres utilisateur.
 * @param {Object} filters - { need, mood, tone, energy }
 * @returns {string} - Phrase optimisée pour la recherche sémantique
 */
export function buildSearchQuery(filters) {
  const {
    need,
    mood,
    needLabel,
    moodLabel,
    needQuestion,
    moodQuestion,
    tone,
    tonePref,
    energy,
    energyCap
  } = filters || {};

  // Normalisation minimale
  const norm = (s) => (s || "").toString().trim();
  const needSlug = norm(need);
  const moodSlug = norm(mood);
  const labelNeed = norm(needLabel);
  const labelMood = norm(moodLabel);
  const qNeed = norm(needQuestion);
  const qMood = norm(moodQuestion);
  const toneVal = norm(tonePref || tone || "");
  const energyVal = norm(energyCap || energy || "");

  // Synonymes pour élargir la recherche sémantique
  const NEED_SYNONYMS = {
    "calme": ["apaiser", "calmer", "apaisement", "sérénité", "tranquillité"],
    "réconfort": ["douceur", "rassurer", "consoler", "réconfortant"],
    "clarté": ["clarifier", "comprendre", "y voir plus clair", "lumière", "expliciter"],
    "élan": ["motivation douce", "envie d’avancer", "impulsion", "dynamisme"],
    "lâcher-prise": ["relâcher", "laisser aller", "lâcher", "souplesse"],
    "perspective": ["prendre du recul", "voir autrement", "changer de point de vue", "relativiser"]
  };
  const MOOD_SYNONYMS = {
    "bien": ["bien", "positif", "apaisé", "serein"],
    "neutre": ["neutre", "indifférent", "plat", "stable"],
    "fatigué": ["fatigué", "épuisé·e", "lassé", "usé"],
    "stressé": ["stressé", "tendu·e", "débordé·e", "anxieux", "angoissé"],
    "triste": ["triste", "chagrin", "morose", "abattu"],
    "motivé": ["motivé", "énergisé·e", "enthousiaste", "partant"]
  };

  // Fallbacks naturels par besoin
  const NEED_EFFECT_FALLBACK = {
    "calme": "m’apaiser",
    "réconfort": "me réconforter",
    "clarté": "m’aider à comprendre",
    "élan": "me donner un petit élan",
    "lâcher-prise": "m’aider à relâcher",
    "perspective": "m’aider à prendre du recul"
  };

  // Fallbacks naturels par humeur
  const MOOD_PHRASE_FALLBACK = {
    "bien": "plutôt bien",
    "neutre": "plutôt neutre",
    "fatigué": "épuisé·e",
    "stressé": "tendu·e",
    "triste": "triste",
    "motivé": "énergisé·e"
  };

  // Déterminer si le label besoin ressemble à un effet verbal de type "m’aiderait …", "m’apaiserait", "me …"
  const looksLikeEffect = (txt) => {
    const t = txt.toLowerCase();
    return /^(m[’']|me\s)/.test(t) || /m’aider/.test(t) || /m’/i.test(t);
  };

  let naturalNeed = "";
  // Ne produire une phrase naturelle que si le label ressemble à un effet (ex: "m’aiderait à …")
  if (labelNeed && looksLikeEffect(labelNeed)) {
    naturalNeed = `Je veux une citation qui ${labelNeed}.`;
  }

  // (pas de phrase humeur — on utilisera un format générique Question/Réponse) 

  // (pas d'indices de ton dans la requête pour rester générique) 

  const synNeed = NEED_SYNONYMS[needSlug] || [];
  const synMood = MOOD_SYNONYMS[moodSlug] || [];

  const lines = [
    naturalNeed,
    (qNeed && labelNeed) ? `Question: "${qNeed}" Réponse: "${labelNeed}"` : "",
    (qMood && labelMood) ? `Question: "${qMood}" Réponse: "${labelMood}"` : "",
    (synNeed.length || synMood.length) ? `Synonymes: ${[...synNeed, ...synMood].join(", ")}` : ""
  ].filter(Boolean);

  return lines.join("\n");
}

/**
 * Vérifie si le serveur RAG est disponible.
 * @returns {Promise<boolean>}
 */
export async function checkHealth() {
  try {
    const response = await fetch('http://localhost:5001/health', {
      method: 'GET',
    });
    return response.ok;
  } catch {
    return false;
  }
}
